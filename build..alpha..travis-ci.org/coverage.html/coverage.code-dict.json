{"/home/travis/build/npmtest/node-npmtest-turbine.js/test.js":"/* istanbul instrument in package npmtest_turbine_js */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - init-after\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - init-after\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-turbine.js/lib.npmtest_turbine.js.js":"/* istanbul instrument in package npmtest_turbine_js */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_turbine_js = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_turbine_js = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-turbine.js/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-turbine.js && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_turbine_js */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_turbine_js\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // init-after\n    // run browser js-env code - init-after\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_turbine_js.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_turbine_js.rollup.js'] =\n            local.assetsDict['/assets.npmtest_turbine_js.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_turbine_js.__dirname + '/lib.npmtest_turbine_js.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-turbine.js/node_modules/turbine.js/src/Turbine.js":"/** @license Turbine.js | MIT License | https://github.com/wmbenedetto/turbine.js#mit-license */\nif (typeof MINIFIED === 'undefined'){\n    MINIFIED = false;\n}\n/**\n *   ________  ______  ____  _____   ________     _______\n *  /_  __/ / / / __ \\/ __ )/  _/ | / / ____/    / / ___/\n *   / / / / / / /_/ / __  |/ //  |/ / __/  __  / /\\__ \\\n *  / / / /_/ / _, _/ /_/ // // /|  / /____/ /_/ /___/ /\n * /_/  \\____/_/ |_/_____/___/_/ |_/_____(_)____//____/\n *\n * Turbine.js : The JavaScript Workflow Engine\n *\n * Copyright (c) 2012 Warren Benedetto <warren@transfusionmedia.com>\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the Software\n * is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n(function(root,undefined) {\n\n    var $                                       = root.jQuery || null;\n\n    if (!MINIFIED){\n\n        var console                             = root.console || {};\n        console.log                             = (typeof console.log   === 'function') ? console.log   : function() {};\n        console.info                            = (typeof console.info  === 'function') ? console.info  : console.log;\n        console.error                           = (typeof console.error === 'function') ? console.error : console.log;\n        console.warn                            = (typeof console.warn  === 'function') ? console.warn  : console.log;\n    }\n\n    /**\n     * Add bind() to Function prototype for browsers that don't yet support ECMAScript 5.\n     *\n     * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/bind\n     */\n    if (typeof Function.prototype.bind !== 'function'){\n\n        Function.prototype.bind = function(scope) {\n\n            var self                            = this;\n\n            return function() {\n                return self.apply(scope,arguments);\n            }\n        };\n    }\n\n    /**\n     * Initializes Turbine via initObj object.\n     *\n     * var initObj = {\n     *\n     *     // THIS IS REQUIRED ...\n     *     workflow    : {},\n     *\n     *     // *OR* THIS IS REQUIRED (BUT NOT BOTH)\n     *     sequence     : [],\n     *\n     *     // OPTIONAL\n     *     name        : '',\n     *     logLevel    : '',\n     *     queries     : {},\n     *     responses   : {},\n     *     resets      : {},\n     *     init        : function(){},\n     *     log         : function(){},\n     *     publish     : function(){},\n     *     listen      : function(){},\n     *     remove      : function(){},\n     *     report      : function(){}\n     * };\n     *\n     * The initObj must define either a workflow OR a sequence (but not both)\n     *\n     * It can also optionally define functions for publish(),\n     * listen(), and remove(). If these aren't defined, jQuery's\n     * trigger/bind/unbind will be used by default.\n     *\n     * The initObj can also define query and reset functions; default responses;\n     * function definitions for init(), log(), and report(); the name of this\n     * Turbine instance (used for logging); and the logLevel.\n     *\n     * @param initObj Initialization object\n     */\n    var Turbine = function Turbine(initObj) {\n\n        if (typeof initObj !== 'object' || initObj === null){\n\n            var errorMsg                        = 'Turbine constructor must be passed an initialization object';\n\n            this.report({\n                handle                          : 'INIT_OBJ_NOT_DEFINED',\n                desc                            : errorMsg\n            });\n\n            throw new Error(errorMsg);\n        }\n\n        if (!MINIFIED){\n\n            this.logLevels = {\n                OFF                             : 0,\n                ERROR                           : 1,\n                WARN                            : 2,\n                INFO                            : 3,\n                DEBUG                           : 4,\n                TRACE                           : 5\n            };\n        }\n\n        this.always                             = {};\n        this.alwaysWaitFor                      = {};\n        this.currentQuery                       = null;\n        this.dirtyQueries                       = {};\n        this.globalTimeoutAllowed               = false;\n        this.logLevel                           = initObj.logLevel  || 'ERROR';\n        this.name                               = initObj.name      || 'Turbine';\n        this.mixins                             = {};\n        this.numGlobalListeners                 = 0;\n        this.queries                            = {};\n        this.queryOrder                         = [];\n        this.resets                             = {};\n        this.responses                          = {};\n        this.shortcuts                          = {};\n        this.started                            = false;\n        this.killed                             = false;\n        this.variables                          = {};\n        this.waitingFor                         = null;\n        this.workflow                           = {};\n\n        this.timers = {\n            queries                             : {},\n            delay                               : null,\n            global                              : null\n        };\n\n        this.initPubSub();\n        this.importFunctions(initObj);\n        this.importObjects(initObj);\n        this.importAlways();\n        this.importMixins();\n\n        if (initObj.workflow) {\n\n            this.importWorkflow(initObj);\n\n        } else if (initObj.sequence) {\n\n            this.importSequence(initObj);\n        }\n\n        if (typeof initObj.init === 'function'){\n            initObj.init(this);\n        }\n    };\n\n    /**\n     * Turbine class prototype\n     */\n    Turbine.prototype = {\n\n        DEFAULT_GLOBAL_TIMEOUT                  : 3600000, // one hour, in milliseconds\n\n        /**\n         * Initializes default publish/listen/remove functions.\n         * These can be overridden by functions defined the initObj\n         * passed to the Turbine constructor\n         */\n        initPubSub : function(){\n\n            var self                            = this;\n\n            this.pubsub = {\n\n                publish : function(message,payload){\n                    $(self).trigger(message,payload);\n                },\n\n                listen : function(message,handler){\n                    $(self).on(message,function(e) {\n                        handler(e.type, e.data);\n                    });\n                },\n\n                remove : function(message){\n                    $(self).unbind(message);\n                }\n            }\n        },\n\n        /**\n         * Imports valid functions specified in initObj to Turbine\n         *\n         * @param initObj Initialization object\n         */\n        importFunctions : function(initObj) {\n\n            if (!MINIFIED){\n                this.log('importFunctions', 'Importing functions', null, 'DEBUG');\n            }\n\n            var thisFunc                        = null;\n            var importedFunctions               = {};\n            var validFunctions = [\n                'init',\n                'log',\n                'publish',\n                'listen',\n                'remove',\n                'report'\n            ];\n\n            for (var i=0;i<validFunctions.length;i++) {\n\n                thisFunc                        = validFunctions[i];\n\n                if (!MINIFIED){\n                    this.log('importFunctions', '--> Importing ' + thisFunc + '() function', null, 'DEBUG');\n                }\n\n                if (typeof initObj[thisFunc] === 'function') {\n\n                    this[thisFunc]              = initObj[thisFunc];\n\n                    importedFunctions[thisFunc] = true;\n                }\n            }\n\n            if (!$ && (!('publish' in importedFunctions) || !('listen' in importedFunctions) || !('remove' in importedFunctions))) {\n\n                var errorMsg                    = '[' + this.name + '.importFunctions()] You must either define publish(), listen(), and remove() functions via the initObj passed to the Turbine constructor, or you must include jQuery in the page.';\n\n                this.report({\n                    handle                      : 'REQUIRED_FUNCTIONS_NOT_DEFINED',\n                    desc                        : errorMsg\n                });\n\n                throw new Error(errorMsg);\n            }\n        },\n\n        /**\n         * Imports valid objects specified in initObj to Turbine\n         *\n         * @param initObj Initialization object\n         */\n        importObjects : function(initObj) {\n\n            if (!MINIFIED){\n                this.log('importObjects', 'Importing objects', null, 'DEBUG');\n            }\n\n            var thisObj                         = null;\n            var validObjects = [\n                'queries',\n                'resets',\n                'responses',\n                'shortcuts',\n                'variables',\n                'always',\n                'mixins'\n            ];\n\n            for (var i=0;i<validObjects.length;i++) {\n\n                thisObj                         = validObjects[i];\n\n                if (!MINIFIED){\n                    this.log('importObjects', '--> Importing ' + thisObj + ' object', null, 'DEBUG');\n                }\n\n                if (this.utils.isObjLiteral(initObj[thisObj])) {\n                    this[thisObj]               = initObj[thisObj];\n                }\n            }\n        },\n\n        /**\n         * Imports workflow\n         *\n         * @param initObj Initialization object\n         */\n        importWorkflow : function(initObj) {\n\n            if (this.utils.isObjLiteral(initObj.workflow)) {\n\n                if (!MINIFIED){\n                    this.log('importWorkflow', 'Importing workflow', null, 'DEBUG');\n                }\n\n                this.workflow                       = initObj.workflow || {};\n\n                this.replaceMixins(this.workflow);\n\n                if (this.utils.isObjLiteral(initObj.workflow)) {\n                    this.importQueries(initObj.workflow);\n                }\n\n            } else {\n\n                var errorMsg                    = '[' + this.name + '.importWorkflow()] Could not import workflow. Workflow must be an object literal.';\n\n                this.report({\n                    handle                      : 'COULD_NOT_IMPORT_WORKFLOW',\n                    desc                        : errorMsg\n                });\n\n                throw new Error(errorMsg);\n            }\n        },\n\n        /**\n         * Imports sequence\n         *\n         * @param initObj Initialization object\n         */\n        importSequence : function(initObj) {\n\n            if (this.utils.isArray(initObj.sequence)) {\n\n                if (!MINIFIED){\n                    this.log('importSequence', 'Importing sequence', null, 'DEBUG');\n                }\n\n                initObj.sequence                = initObj.sequence || [];\n                initObj.workflow                = this.importSequenceQueries(initObj.sequence);\n                initObj.sequence                = null;\n\n                this.importWorkflow(initObj);\n\n            } else {\n\n                var errorMsg                    = '[' + this.name + '.importSequence()] Could not import sequence. Sequence must be an array.';\n\n                this.report({\n                    handle                      : 'COULD_NOT_IMPORT_SEQUENCE',\n                    desc                        : errorMsg\n                });\n\n                throw new Error(errorMsg);\n            }\n        },\n\n        /**\n         * Imports sequence queries, converting them to a regular workflow.\n         * Sequence steps are re-named to queries named like \"SEQUENCE_STEP_1\", \"SEQUENCE_STEP_2\", etc.\n         * with the sequence step body converted to the \"default\" response for the query.\n         *\n         * @param  {Array} sequence  Array of query responses\n         * @return {Object}          Regular workflow object\n         */\n        importSequenceQueries : function(sequence) {\n\n            var workflow                        = {};\n            var len                             = sequence.length;\n            var self                            = this;\n            var stepBaseName                    = 'SEQUENCE_STEP_';\n\n            /* Create regular workflow object from sequence array */\n            for (var i=0;i<len;i++) {\n\n                var query                       = sequence[i];\n                var currentStepCount            = i + 1;\n\n                (function(q,c){\n\n                    /* Rewrite every instance of \"then\" in the query objects */\n                    self.utils.traverseObj(q, 0, function(obj, item) {\n\n                        /* Replace \"@next\" with the name of the next query (or with \"stop.\" if it's the last query) */\n                        if (item === 'then' && obj[item] === '@next') {\n                            var nextStepCount   = c + 1;\n                            obj[item]           = (nextStepCount > sequence.length) ? 'stop.' : stepBaseName + nextStepCount;\n                        }\n                    });\n\n                }(query,currentStepCount));\n\n\n                /* Name all queries in sequence as \"SEQUENCE_STEP_1\", \"SEQUENCE_STEP_2\", etc.\n                 * Only the \"default\" response body is needed since all query responses default to \"default\" */\n                workflow[stepBaseName + currentStepCount]    = { default : query };\n            }\n\n            return workflow;\n        },\n\n        /**\n         * Imports \"always\" from initObj\n         */\n        importAlways : function() {\n\n            if (!MINIFIED){\n                this.log('importAlways', 'Importing always', this.always, 'DEBUG');\n            }\n\n            if (typeof this.always.waitFor !== 'undefined'){\n\n                this.replaceShortcuts(this.always.waitFor);\n                this.replaceVariables(this.always.waitFor);\n\n                var result                      = this.parseWaitFor(this.always.waitFor);\n\n                this.alwaysWaitFor              = result.nextQueryObj;\n                this.numAlwaysWaitFor           = result.waitingFor.length;\n\n                if (!MINIFIED){\n                    this.log('importAlways', 'Always wait for', this.alwaysWaitFor, 'DEBUG');\n                }\n            }\n\n            /* If a global timeout is specified then global timeouts are allowed by default */\n            this.globalTimeoutAllowed           = typeof this.always.timeout !== 'undefined';\n        },\n\n        /**\n         * Imports mixins, recursively replacing any nested mixins\n         */\n        importMixins : function(){\n\n            if (!MINIFIED){\n                this.log('importMixins', 'Importing mixins', this.mixins, 'DEBUG');\n            }\n\n            for (var mixin in this.mixins){\n\n                if (this.mixins.hasOwnProperty(mixin)){\n                    this.replaceMixins(this.mixins[mixin]);\n                }\n            }\n        },\n\n        /**\n         * Imports workflow queries\n         *\n         * @param workflow The workflow object containing the queries\n         */\n        importQueries : function(workflow) {\n\n            if (!MINIFIED){\n                this.log('importQueries', 'Importing queries', workflow, 'DEBUG');\n            }\n\n            var totalQueries                    = 0;\n\n            /* Imports each query in the workflow */\n            for (var query in workflow) {\n\n                if (workflow.hasOwnProperty(query)) {\n\n                    this.importQuery(query,workflow);\n\n                    totalQueries               += 1;\n                }\n            }\n\n            if (totalQueries === 0) {\n\n                var errorMsg                    = '[' + this.name + '.importQueries()] The workflow has no queries to import';\n\n                this.report({\n                    handle                      : 'NO_QUERIES_TO_IMPORT',\n                    desc                        : errorMsg\n                });\n\n                throw new Error(errorMsg);\n            }\n        },\n\n        /**\n         * Imports a single query from the workflow\n         *\n         * @param query The query to import\n         * @param workflow The workflow being imported\n         */\n        importQuery : function(query,workflow) {\n\n            if (!MINIFIED){\n                this.log('importQuery', 'Importing workflow query: ' + query, workflow[query], 'TRACE');\n            }\n\n            this.queries[query]                 = this.queries[query] || null;\n\n            /* Store queries in array so they can be accessed numerically */\n            this.queryOrder.push(query);\n\n            this.replaceMixins(query);\n\n            for (var response in workflow[query]) {\n\n                if (workflow[query].hasOwnProperty(response)) {\n                    this.importResponse(response,query,workflow);\n                }\n            }\n        },\n\n        /**\n         * Imports one response for one workflow query\n         *\n         * @param response The response to import\n         * @param query The query being imported\n         * @param workflow The workflow being imported\n         */\n        importResponse : function(response,query,workflow) {\n\n            var thisResponse                    = workflow[query][response];\n\n            if (!MINIFIED){\n                this.log('importResponse', 'Importing ' + response + ' response to ' + query + ' query', thisResponse, 'TRACE');\n            }\n\n            /* Add counter to any repeat object */\n            if (thisResponse.repeat) {\n                thisResponse.repeat.counter = 0;\n            }\n\n            this.replaceShortcuts(thisResponse);\n            this.replaceVariables(thisResponse);\n        },\n\n        /**\n         * Default log() implementation\n         *\n         * This can be overridden by defining a log() function in the initObj\n         * passed to the constructor\n         *\n         * @param funcName The name of the function generating the log message\n         * @param message The message to log\n         * @param payload Data object\n         * @param level Log level (ERROR, WARN, INFO, DEBUG)\n         */\n        log : function(funcName,message,payload,level) {\n\n            if (!MINIFIED){\n                payload                         = (!payload) ? '' : payload;\n                level                           = (!level) ? 'INFO' : level;\n                message                         = '[' + this.name + '.' + funcName + '()] ' + message;\n\n                if (this.isLoggable(level)) {\n\n                    switch (level){\n\n                        case 'ERROR':\n                            console.error(message,payload);\n                            break;\n                        case 'WARN':\n                            console.warn(message,payload);\n                            break;\n                        case 'INFO':\n                            console.info(message,payload);\n                            break;\n                        default:\n                            console.log(message,payload);\n                            break;\n                    }\n                }\n            }\n        },\n\n        /**\n         * Checks whether the given level is loggable based on the\n         * current log level\n         *\n         * @param level The level to check\n         * @return {Boolean}\n         */\n        isLoggable : function(level){\n\n            if (!MINIFIED){\n                return this.logLevels[level] <= this.logLevels[this.logLevel];\n            }\n\n            return false;\n        },\n\n        /**\n         * Default implementation of report() method. Used to report errors in Turbine.\n         * This can be overridden by defining a report() method in the initObj passed to\n         * the constructor.\n         *\n         * @param obj Object containing handle, description, and/or payload\n         */\n        report : function(obj) {\n\n            if (!MINIFIED){\n\n                obj                             = (this.utils.isObjLiteral(obj)) ? obj : {};\n                var handle                      = obj.handle || 'WORKFLOW_ISSUE_REPORTED';\n                var desc                        = obj.description || '';\n\n                this.log('report', handle + ': ' + desc, obj, 'ERROR');\n            }\n\n            return null;\n        },\n\n        /**\n         * Default implementation of publish() method, using jQuery's trigger() function\n         * to publish messages.\n         *\n         * This can be overridden by defining a publish() method in the initObj passed to\n         * the constructor.\n         *\n         * @param message The message or array of messages to publish\n         * @param payload Data object\n         * @param callback Function to call once message(s) is published\n         */\n        publish : function(message,payload,callback) {\n\n            payload                             = payload || {};\n\n            if (!MINIFIED){\n                this.log('publish', 'Publishing message:', message);\n            }\n\n            if (typeof message === 'string') {\n                message                         = [message];\n            }\n\n            for (var i=0;i<message.length;i++) {\n                this.pubsub.publish(message[i],payload);\n            }\n\n            if (typeof callback === 'function') {\n                callback();\n            }\n        },\n\n        /**\n         * Default implementation of listen() method, using jQuery's bind() function\n         * to bind handlers to messages.\n         *\n         * This can be overridden by defining a listen() method in the initObj passed to\n         * the constructor.\n         *\n         * @param message The message for which to listen\n         * @param handler The function to execute upon receiving the message\n         */\n        listen : function(message,handler) {\n\n            if (!MINIFIED){\n                this.log('listen', 'Adding listener for:', message, 'TRACE');\n            }\n\n            if (typeof message === 'string') {\n                message                         = [message];\n            }\n\n            for (var i=0;i<message.length;i++) {\n                this.pubsub.listen(message[i],handler);\n            }\n        },\n\n        /**\n         * Default implementation of remove() method, using jQuery's unbind() function\n         * to unbind handlers from messages.\n         *\n         * This can be overridden by defining a remove() method in the initObj passed to\n         * the constructor.\n         *\n         * @param message The message for which to stop listening\n         */\n        remove : function(message) {\n\n            if (!MINIFIED){\n                this.log('remove', 'Removing listener for:', message, 'TRACE');\n            }\n\n            if (typeof message === 'string') {\n                message                         = [message];\n            }\n\n            for (var i=0;i<message.length;i++) {\n                 this.pubsub.remove(message[i]);\n            }\n        },\n\n        /**\n         * Starts Turbine by executing the first queued query\n         */\n        start : function() {\n\n            if (this.isKilled()){\n\n                if (!MINIFIED){\n                    this.log('start', 'Cannot start Turbine. It has already been killed.', null, 'ERROR');\n                }\n\n                return null;\n            }\n\n            if (!MINIFIED){\n                this.log('start', 'Starting Turbine');\n            }\n\n            this.started                        = true;\n\n            this.queue(null,this.getStartingQuery());\n            this.next();\n        },\n\n        /**\n         * Stops Turbine\n         */\n        stop : function() {\n\n            if (!MINIFIED){\n                this.log('stop', 'Stopping Turbine');\n            }\n\n            this.started                        = false;\n\n            this.rewind();\n        },\n\n        /**\n         * Kills Turbine (It is stopped and can't be restarted)\n         */\n        kill : function(){\n\n            if (!MINIFIED){\n                this.log('kill', 'Killing Turbine');\n            }\n\n            this.started                        = false;\n            this.killed                         = true;\n\n            this.rewind();\n        },\n\n        /**\n         * Shortcut for executing next query\n         */\n        next : function() {\n\n            if (this.isKilled() || this.nextQuery === null) {\n                return null;\n            }\n\n            if (!MINIFIED){\n                this.log('next', 'Executing next workflow query:', this.nextQuery, 'TRACE');\n            }\n\n            this.exec(this.nextQuery);\n        },\n\n        /**\n         * Executes a query\n         *\n         * @param query The query to execute\n         */\n        exec : function(query) {\n\n            this.clearTimers();\n\n            if (this.isKillQuery(query)) {\n                this.kill();\n            }\n\n            if (this.isStopQuery(query)) {\n                this.stop();\n                return null;\n            }\n\n            if (this.isKilled()) {\n                return null;\n            }\n\n            this.currentQuery                   = query;\n            this.nextQuery                      = null;\n            this.responses[query]               = this.getResponse(query);\n\n            /* If the query doesn't exist, we can't go any further */\n            if (!this.utils.isObjLiteral(this.workflow[query])) {\n\n                this.report({\n                    handle                      : 'QUERY_DOES_NOT_EXIST',\n                    desc                        : '[' + this.name + '.exec()] ' + query + ' query does not exist'\n                });\n\n                return null;\n            }\n\n            var responseName                    = this.responses[query];\n            var responseObj                     = this.workflow[query][responseName];\n\n            /* If the response doesn't exist, check if a default response has been specified */\n            if (!responseObj) {\n\n                responseName                    = 'default';\n                responseObj                     = this.workflow[query][responseName];\n\n                /* If there's no default response specified either, then there's nothing else we can do */\n                if (!responseObj) {\n\n                    this.report({\n                        handle                  : 'RESPONSE_DOES_NOT_EXIST',\n                        desc                    : '[' + this.name + '.exec()] ' + responseName + ' response does not exist for the ' + query + ' query'\n                    });\n\n                    return null;\n                }\n            }\n\n            if (!MINIFIED){\n                this.log('exec', 'Executing the ' + responseName + ' response to the ' + query + ' query', responseObj, 'DEBUG');\n            }\n\n            responseObj.responseName            = responseName;\n\n            this.processResponse(query,responseObj);\n        },\n\n        /**\n         * Processes a query's response, executing its the workflow logic\n         *\n         * @param query The query containing the response to process\n         * @param response The response to process\n         * @param preventGlobalTimeout If true, global timeout will not be started\n         */\n        processResponse : function(query,response,preventGlobalTimeout) {\n\n            this.clearTimers();\n\n            if (this.isKilled()) {\n                return null;\n            }\n\n            if (!MINIFIED){\n                this.log('processResponse', 'Processing response to '+query+' query', response, 'TRACE');\n            }\n\n            if (!preventGlobalTimeout) {\n                this.startGlobalTimeout(query,response);\n            }\n\n            if (response.delay && !response.isAfterDelay) {\n\n                this.startDelayTimeout(query,response);\n\n            } else {\n\n                /* \"report\" tells us to report an issue. We only want to report it once, so\n                 * we ignore it if we're processing the response as part of a publish callback */\n                if (response.report && !response.isPublishCallback) {\n                    this.reportIssueFromWorkflow(query,response);\n                }\n\n                /* If we have \"publish\" with no \"waitFor\", then just publish the message and move on */\n                if (response.publish && !response.waitFor && !response.isPublishCallback) {\n\n                    this.publishNow(query,response);\n                }\n\n                /* If we have \"publish\" with \"waitFor\", then publish the message and wait for a response\n                 * before continuing. */\n                if (response.publish && response.waitFor && !response.isPublishCallback) {\n\n                    this.publishAndWait(query,response);\n\n                } else {\n\n                    if (response.repeat) {\n\n                        /* Clean up isAfterDelay flag */\n                        if (response.isAfterDelay) {\n\n                            try {\n                                delete response.isAfterDelay;\n                            } catch (e) {\n                                response.isAfterDelay       = undefined;\n                            }\n                        }\n\n                        /* \"repeat\" repeats query */\n                        this.repeat(query,response);\n\n                    }\n                    /* \"waitFor\" tells us to wait for a message (or messages) before executing \"then\" query */\n                    else if (response.waitFor) {\n\n                        this.queue(response.waitFor,response.then);\n\n                    }\n                    /* Otherwise, \"then\" query gets executed immediately */\n                    else if (response.then){\n\n                        if (this.isEarlierQuery(response.then,this.currentQuery)){\n                            this.rewind(this.currentQuery,response.then);\n                        }\n\n                        this.exec(response.then);\n                    }\n\n                    /* Clean up isPublishCallback flag */\n                    if (response.isPublishCallback) {\n\n                        try {\n                            delete response.isPublishCallback;\n                        } catch (e) {\n                            response.isPublishCallback  = undefined;\n                        }\n                    }\n\n                    /* If this response has a timeout, set the timer */\n                    if (response.timeout) {\n                        this.setResponseTimeout(query,response);\n                    }\n\n                    /* Clean up isAfterDelay flag */\n                    if (response.isAfterDelay) {\n\n                        try {\n                            delete response.isAfterDelay;\n                        } catch (e) {\n                            response.isAfterDelay       = undefined;\n                        }\n                    }\n                }\n            }\n        },\n\n        /**\n         * Reports an issue from the workflow\n         *\n         * @param query The query being executed\n         * @param response The response containing the report\n         */\n        reportIssueFromWorkflow : function(query,response){\n\n            var responseName                    = this.responses[query];\n            response.report                     = (this.utils.isObjLiteral(response.report)) ? response.report : {};\n\n            /* Add workflow info to report */\n            response.report.workflow = {\n                name                            : this.name,\n                query                           : query,\n                response                        : responseName,\n                responseObj                     : this.workflow[query][responseName],\n                timestamp                       : new Date().getTime()\n            };\n\n            this.report(response.report);\n        },\n\n        /**\n         * Sets response timeout\n         *\n         * @param query The query being executed\n         * @param response The response containing the timeout\n         */\n        setResponseTimeout : function(query, response) {\n\n            if (!this.timers.queries[query]) {\n                this.timers.queries[query]      = [];\n            }\n\n            var self                            = this;\n\n            var timeout = setTimeout(function() {\n\n                self.onResponseTimeout(query,response);\n\n            },response.timeout.after);\n\n            this.timers.queries[query].push(timeout);\n        },\n\n        /**\n         * Repeats query on each message until limit is reached, after which the\n         * fallback response is performed. If the limit is null, query can repeat infinitely.\n         *\n         * @param query The query to repeat\n         * @param response The response to repeat\n         */\n        repeat : function(query,response) {\n\n            response.repeat.counter            += 1;\n\n            if (!MINIFIED){\n                this.log('repeat', 'Repeating ' + query + ' (' + response.repeat.counter + ' of ' + response.repeat.limit + ' max)');\n            }\n\n            /* If the limit is null, repeat query indefinitely */\n            if (response.repeat.limit === null) {\n\n                this.queue(response.waitFor,query);\n            }\n            /* If the limit has been reached, use fallback response */\n            else if (response.repeat.counter >= response.repeat.limit) {\n\n                if (!MINIFIED){\n                    this.log('repeat', 'Maximum repeat limit for ' + query + ' reached or exceeded (' + response.repeat.counter + ' of ' + response.repeat.limit + ' max)');\n                }\n\n                this.processResponse(query,response.repeat);\n            }\n            /* If limit hasn't been reached, queue or execute same query again */\n            else {\n\n                if (response.waitFor) {\n\n                    /* When waitFor is an array, it is passed by reference. Because the global listeners are added\n                     * every time we call queue(), and because waitFor is a reference, the global listeners end up\n                     * being pushed onto the array over and over. Slicing them off here means they can be added again\n                     * without stacking up. */\n                    if (this.utils.isArray(response.waitFor) && response.repeat.counter > 1) {\n                        response.waitFor        = response.waitFor.slice(0,response.waitFor.length - this.numAlwaysWaitFor);\n                    }\n\n                    this.queue(response.waitFor,query);\n\n                } else {\n\n                    this.exec(query);\n                }\n            }\n        },\n\n        /**\n         * Rewinds back to earlier query, resetting queries' flags and counters\n         * along the way.\n         *\n         * @param from The query from which to start the rewind\n         * @param to The query to which we're rewinding\n         */\n        rewind : function(from,to) {\n\n            this.clearTimers();\n\n            var clearing                        = false;\n            var numQueries                      = this.queryOrder.length;\n            from                                = from || this.queryOrder[numQueries-1];\n            to                                  = to || this.queryOrder[0];\n\n            if (!MINIFIED){\n                this.log('rewind', 'Rewinding from ' + from + ' to ' + to, null, 'DEBUG');\n            }\n\n            for (var i=numQueries;i>=0;i--) {\n\n                var query                       = this.queryOrder[i];\n\n                if (query === from) {\n                    clearing                    = true;\n                }\n\n                if (clearing) {\n                    this.clear(query);\n                }\n\n                if (query === to) {\n                    break;\n                }\n            }\n        },\n\n        /**\n         * Checks whether the new query is earlier than the current query\n         * (e.g. we're going backwards in the workflow)\n         *\n         * @param nextQuery The query to execute next\n         * @param currentQuery The query we're currently executing\n         */\n        isEarlierQuery : function(nextQuery,currentQuery) {\n\n            if (currentQuery === nextQuery) {\n                return false;\n            }\n\n            for (var i=0;i<this.queryOrder.length;i++) {\n\n                if (this.queryOrder[i] === nextQuery) {\n                    return true;\n                }\n\n                if (this.queryOrder[i] === currentQuery) {\n                    return false;\n                }\n            }\n\n            return false;\n        },\n\n        /**\n         * Clears query's flags and timeouts and resets counters\n         *\n         * @param query The query to clear\n         */\n        clear : function(query) {\n\n            if (!MINIFIED){\n                this.log('clear', 'Clearing ' + query, null, 'DEBUG');\n            }\n\n            this.clearQueryTimer(query);\n\n            /* Reset counters for repeat queries */\n            for (var response in this.workflow[query]) {\n\n                if (this.workflow[query].hasOwnProperty(response) && this.workflow[query][response].repeat) {\n\n                    this.workflow[query][response].repeat.counter = 0;\n                }\n            }\n\n            this.resetResponse(query);\n        },\n\n        /**\n         * Checks whether there's a function to get a response to the query\n         *\n         * @param query The query for which to get a function\n         */\n        hasQueryFunction : function(query) {\n            return typeof this.queries[query] === 'function';\n        },\n\n        /**\n         * Resets the response to a query\n         *\n         * @param query The query for which the response should be reset\n         */\n        resetResponse : function(query) {\n\n            /* If the query is dirty, just clear the dirty flag. Don't reset the response. */\n            if (this.isDirtyQuery(query)){\n\n                this.dirtyQueries[query]        = null;\n\n            }\n            /* If the query isn't dirty, reset the response */\n            else {\n\n                var didReset                    = false;\n\n                if (typeof this.resets[query] === 'function'){\n\n                    this.responses[query]       = this.resets[query]();\n                    didReset                    = true;\n\n                } else if (typeof this.resets[query] !== 'undefined'){\n\n                    this.responses[query]       = this.resets[query];\n                    didReset                    = true;\n                }\n\n                if (!MINIFIED){\n\n                    if (didReset){\n                        this.log('resetResponse', 'Reset ' + query + ' response to', this.responses[query] || 'false', 'DEBUG');\n                    }\n                }\n            }\n        },\n\n        /**\n         * Callback executed when query response times out\n         *\n         * @param query The query being executed\n         * @param response The response containing the timeout\n         */\n        onResponseTimeout : function(query,response) {\n\n            if (!MINIFIED){\n                this.log('onResponseTimeout', 'The ' + query + ' response timed out.', response, 'WARN');\n            }\n\n            if (this.waitingFor) {\n                this.remove(this.waitingFor);\n            }\n\n            /* Set flag so timeout isn't triggered again during reprocessing */\n            response.timeout.isAfterTimeout     = true;\n\n            this.processResponse(query,response.timeout,true);\n        },\n\n        /**\n         * Publishes workflow message immediately\n         *\n         * @param query The query being executed\n         * @param response The response being processed\n         */\n        publishNow : function(query,response) {\n\n            var message                         = null;\n            var using                           = {};\n\n            if (this.utils.isObjLiteral(response.publish)) {\n\n                message                         = response.publish.message;\n                using                           = this.getUsingObject(response.publish.using);\n\n            } else {\n\n                message                         = response.publish;\n            }\n\n            this.publish(message,using);\n        },\n\n        /**\n         * Publishes message, then waits until the callback is called before moving to the next step.\n         *\n         * @param query The query containing the message to publish\n         * @param response The response being processed\n         */\n        publishAndWait : function(query,response) {\n\n            var self                            = this;\n            var message                         = null;\n            var using                           = {};\n\n            if (this.utils.isObjLiteral(response.publish)) {\n\n                message                         = response.publish.message;\n                using                           = this.getUsingObject(response.publish.using);\n\n            } else {\n\n                message                         = response.publish;\n            }\n\n            using.counter                       = (typeof response.repeat !== 'undefined') ? response.repeat.counter : 0;\n\n            if (!MINIFIED){\n                this.log('publishAndWait', 'Publishing message and waiting for response', {\n\n                    message                     : message,\n                    using                       : using,\n                    response                    : response\n                });\n            }\n\n            /* After message is published, callback must be called to process the rest of the response */\n            var callback = function() {\n\n                response.isPublishCallback      = true;\n\n                self.processResponse(query,response);\n            };\n\n            this.publish(message,using,callback);\n        },\n\n        /**\n         * Merges response's \"using\" object with always.using object (if it is defined).\n         *\n         * @param using The response's \"using\" object\n         */\n        getUsingObject : function(using) {\n\n            using                               = (typeof using === 'undefined') ? {} : using;\n\n            /* If an always.using object has been defined, merge it into the response's using object */\n            if (this.always.using) {\n                using                           = this.utils.mergeObjects(using,this.always.using);\n            }\n\n            if (!MINIFIED){\n                this.log('getUsingObject', 'Getting using object', using, 'TRACE');\n            }\n\n            return using;\n        },\n\n        /**\n         * Starts delay timer\n         *\n         * @param query The query being delayed\n         * @param response The response being delayed\n         */\n        startDelayTimeout : function(query,response) {\n\n            if (!MINIFIED){\n                this.log('startDelayTimeout',query + ' delay started. Delayed for ' + response.delay.for + ' ms', response);\n            }\n\n            var self                            = this;\n\n            this.timers.delay = setTimeout(function() {\n\n                self.onDelayTimeout(query,response);\n\n            },response.delay.for);\n        },\n\n        /**\n         * Callback executed when delay timer expires\n         *\n         * @param query The query being delayed\n         * @param response The response being delayed\n         */\n        onDelayTimeout : function(query,response) {\n\n            if (!MINIFIED){\n                this.log('onDelayTimeout',query + ' delay completed after ' + response.delay.for + ' ms', response);\n            }\n\n            this.processResponse(query,response.delay);\n        },\n\n        /**\n         * Gets the query with which to start the workflow. If a @start shortcut\n         * is specified, that is used. Otherwise, the first query in the workflow is used.\n         *\n         * @return {String}\n         */\n        getStartingQuery : function() {\n\n            var start                           = this.getShortcut('start');\n\n            return (start) ? start : this.queryOrder[0];\n        },\n\n        /**\n         * Queues query to be executed on next message\n         *\n         * @param waitFor The message(s) to wait for before executing the next query\n         * @param nextQuery The query to queue\n         */\n        queue : function(waitFor,nextQuery) {\n\n            if (this.waitingFor) {\n                this.remove(this.waitingFor);\n            }\n\n            var result                          = this.parseWaitFor(waitFor,nextQuery,true);\n\n            this.waitingFor                     = result.waitingFor;\n            this.nextQueryObj                   = result.nextQueryObj;\n            this.nextQuery                      = nextQuery;\n\n            if (this.waitingFor.length > 0){\n                this.listen(this.waitingFor,this.handleIncomingMessage.bind(this));\n            }\n\n            if (!MINIFIED){\n\n                if (this.waitingFor.length > 0){\n                    this.log('queue', 'Waiting for', this.waitingFor);\n                }\n\n                this.log('queue', 'Queuing next query', this.nextQueryObj);\n            }\n        },\n\n        /**\n         * Parses waitFor into two forms: an array of the messages to wait for,\n         * and an object that maps messages to the next query to execute when the\n         * message is received.\n         *\n         * waitFor can either be a message, an array of messages, an object with a\n         * message property, or an array of objects with message properties.\n         *\n         * @param waitFor Message or array of messages to wait for\n         * @param nextQuery The query to queue (\"then\")\n         * @param appendAlwaysWaitFor If true, always waitFor values are included\n         */\n        parseWaitFor : function(waitFor,nextQuery,appendAlwaysWaitFor) {\n\n            var waitingFor                      = [];\n            var nextQueryObj                    = {};\n\n            if (waitFor){\n\n                /* waitFor is a single message, so we map it to nextQuery */\n                if (typeof waitFor === 'string'){\n\n                    waitingFor.push(waitFor);\n                    nextQueryObj[waitFor] = nextQuery;\n\n                } else {\n\n                    if (this.utils.isObjLiteral(waitFor)) {\n                        waitFor                 = [waitFor];\n                    }\n\n                    for (var j=0;j<waitFor.length;j++){\n\n                        if (typeof waitFor[j] === 'string'){\n\n                            waitingFor.push(waitFor[j]);\n                            nextQueryObj[waitFor[j]] = nextQuery;\n\n                        } else if (typeof waitFor[j].message !== 'undefined'){\n\n                            if (this.utils.isArray(waitFor[j].message)){\n\n                                for (var k=0;k<waitFor[j].message.length;k++){\n                                    waitingFor.push(waitFor[j].message[k]);\n                                    nextQueryObj[waitFor[j].message[k]] = waitFor[j].then || nextQuery;\n                                }\n\n                            } else {\n\n                                waitingFor.push(waitFor[j].message);\n                                nextQueryObj[waitFor[j].message] = waitFor[j].then || nextQuery;\n                            }\n                        }\n                    }\n                }\n            }\n\n            /* Add global listeners to waitingFor array, if they're not already there */\n            if (appendAlwaysWaitFor){\n\n                for (var msg in this.alwaysWaitFor) {\n\n                    if (this.alwaysWaitFor.hasOwnProperty(msg)) {\n\n                        waitingFor.push(msg);\n                        nextQueryObj[msg] = this.alwaysWaitFor[msg] || nextQuery;\n                    }\n                }\n            }\n\n            return {\n                waitingFor   : waitingFor,\n                nextQueryObj : nextQueryObj\n            }\n        },\n\n        /**\n         * Handles an incoming message\n         *\n         * @param message The message being handled\n         * @param payload The message payload\n         */\n        handleIncomingMessage : function(message,payload) {\n\n            if (this.isKilled()) {\n                return null;\n            }\n\n            if (!MINIFIED){\n                this.log('handleIncomingMessage', 'Handling \"'+message+'\" message', payload);\n            }\n\n            if (this.waitingFor) {\n\n                this.remove(this.waitingFor);\n\n                this.nextQuery                  = this.getNextQuery(message);\n            }\n\n            this.waitingFor                     = null;\n\n            if (this.isEarlierQuery(this.nextQuery,this.currentQuery)){\n                this.rewind(this.currentQuery,this.nextQuery);\n            }\n\n            if (!this.isKilled()){\n                this.next();\n            }\n\n            return true;\n        },\n\n        /**\n         * Gets the next query to execute based on the message being handled.\n         *\n         * @param message The message being handled\n         */\n        getNextQuery : function(message) {\n\n            var next                            = null;\n\n            for (var msg in this.nextQueryObj) {\n\n                if (this.nextQueryObj.hasOwnProperty(msg) && message === msg) {\n                    next                        = this.nextQueryObj[msg];\n                    break;\n                }\n            }\n\n            if (!MINIFIED){\n                this.log('getNextQuery', 'Getting the next query: '+next, null, 'TRACE');\n            }\n\n            return next;\n        },\n\n        /**\n         * Clears all timers: queries, delays, and global\n         */\n        clearTimers : function() {\n\n            if (!MINIFIED){\n                this.log('clearTimers', 'Clearing all timers', this.timers, 'TRACE');\n            }\n\n            this.clearAllQueryTimers();\n            this.clearGlobalTimer();\n            this.clearDelayTimer();\n        },\n\n        /**\n         * Clears all timers for all queries\n         */\n        clearAllQueryTimers : function() {\n\n            if (!MINIFIED){\n                this.log('clearAllQueryTimers', 'Clearing all query timers', this.timers.queries, 'TRACE');\n            }\n\n            for (var query in this.timers.queries) {\n\n                if (this.timers.queries.hasOwnProperty(query)) {\n\n                    this.clearQueryTimer(query);\n                }\n            }\n        },\n\n        /**\n         * Clears timers for specified query\n         *\n         * @param query The query for which to clear timers\n         */\n        clearQueryTimer : function(query) {\n\n            var timerArray                      = this.timers.queries[query];\n\n            if (timerArray) {\n\n                if (!MINIFIED){\n                    this.log('clearQueryTimer', 'Clearing '+query+' query timer', this.timers.queries[query], 'TRACE');\n                }\n\n                for (var i=0;i<timerArray.length;i++) {\n                    clearTimeout(timerArray[i]);\n                }\n\n                try {\n                    delete this.timers.queries[query];\n                } catch (e) {\n                    this.timers.queries[query]  = undefined;\n                }\n            }\n        },\n\n        /**\n         * Clears global workflow timer\n         */\n        clearGlobalTimer : function() {\n\n            if (this.timers.global !== null) {\n\n                if (!MINIFIED){\n                    this.log('clearGlobalTimer', 'Clearing global timer', this.timers.global, 'TRACE');\n                }\n\n                clearTimeout(this.timers.global);\n\n                this.timers.global              = null;\n            }\n        },\n\n        /**\n         * Clears delay timer\n         */\n        clearDelayTimer : function() {\n\n            if (this.timers.delay !== null) {\n\n                if (!MINIFIED){\n                    this.log('clearDelayTimer', 'Clearing delay timer', this.timers.delay, 'TRACE');\n                }\n\n                clearTimeout(this.timers.delay);\n\n                this.timers.delay               = null;\n            }\n        },\n\n        /**\n         * Starts global timeout timer, which will fire if Turbine hasn't reached a stop\n         * query within the global timeout limit\n         *\n         * @param query The active query when the timeout is set\n         * @param response The response being processed\n         * @return {Boolean}\n         */\n        startGlobalTimeout : function(query,response) {\n\n            if (!this.isGlobalTimeoutAllowed()) {\n                return false;\n            }\n\n            this.clearGlobalTimer();\n\n            if (!MINIFIED){\n                this.log('startGlobalTimeout', 'Starting global timer', this.always.timeout, 'TRACE');\n            }\n\n            var timeout                         = this.getGlobalTimeout();\n            var self                            = this;\n\n            this.timers.global = setTimeout(function() {\n\n                self.onGlobalTimeout(query,response);\n\n            },timeout);\n\n            return true;\n        },\n\n        /**\n         * Gets the length of the global timeout, in milliseconds\n         *\n         * @return {Number}\n         */\n        getGlobalTimeout : function() {\n\n            if (this.utils.isObjLiteral(this.always.timeout) && typeof this.always.timeout.after !== 'undefined'){\n\n                return this.always.timeout.after;\n\n            } else {\n\n                return this.DEFAULT_GLOBAL_TIMEOUT;\n            }\n        },\n\n        /**\n         * Callback to execute when global timeout timer fires\n         *\n         * @param query The active query when the timeout was set\n         * @param response The response that was being processed when the timeout was set\n         */\n        onGlobalTimeout : function(query,response) {\n\n            if (this.waitingFor) {\n                this.remove(this.waitingFor);\n            }\n\n            if (!MINIFIED){\n                this.log('onGlobalTimeout', 'Turbine timed out on ' + query + ' query after ' + this.getGlobalTimeout() + ' ms',null,'ERROR');\n            }\n\n            /* Set flag so timeout isn't triggered again during reprocessing */\n            this.always.timeout.isAfterTimeout  = true;\n\n            this.processResponse(null,this.always.timeout,true);\n        },\n\n        /**\n         * Checks whether global timeout is allowed to be set\n         *\n         * @return {Boolean}\n         */\n        isGlobalTimeoutAllowed : function() {\n            return this.globalTimeoutAllowed === true;\n        },\n\n        /**\n         * Checks whether Turbine has been killed\n         */\n        isKilled : function() {\n            return this.killed === true;\n        },\n\n        /**\n         * Checks whether Turbine is stopped\n         */\n        isStopped : function() {\n            return this.started !== true;\n        },\n\n        /**\n         * Checks whether Turbine is started\n         *\n         * @return {Boolean}\n         */\n        isStarted : function(){\n            return this.started === true;\n        },\n\n        /**\n         * Checks whether the query is a stop query, meaning\n         * the workflow should stop when it is encountered.\n         *\n         * @param query The query to check\n         */\n        isStopQuery : function(query) {\n            return query === 'stop.'\n        },\n\n        /**\n         * Checks whether the query is a kill query, meaning\n         * the workflow should be killed when it is encountered.\n         *\n         * @param query The query to check\n         */\n        isKillQuery : function(query) {\n            return query === 'kill!'\n        },\n\n        /**\n         * Checks whether a query is \"dirty\": its response has been set\n         * via setResponse() while waiting for a message.\n         *\n         * @param query The query to check\n         * @returns {boolean}\n         */\n        isDirtyQuery : function(query){\n            return this.dirtyQueries[query] === true;\n        },\n\n        /**\n         * Sets response to query\n         *\n         * @param query The query for which to set the response\n         * @param response The response to set\n         */\n        setResponse : function(query,response) {\n\n            if (!MINIFIED){\n                this.log('setResponse', 'Setting \"' + query + '\" response to ' + response);\n            }\n\n            this.responses[query]               = response;\n            this.dirtyQueries[query]            = true;\n        },\n\n        /**\n         * Gets the response to a query\n         *\n         * @param query The query for which to get the response\n         */\n        getResponse : function(query) {\n\n            this.responses[query]               = (this.hasQueryFunction(query)) ? this.queries[query]() : this.responses[query];\n\n            /* Convert boolean result to yes/no string */\n            if (typeof this.responses[query] === 'boolean' || this.responses[query] === null || typeof this.responses[query] === 'undefined') {\n                this.responses[query]           = (this.responses[query]) ? 'yes' : 'no';\n            }\n\n            if (!MINIFIED){\n                this.log('getResponse',query + '?', this.responses[query]);\n            }\n\n            return this.responses[query];\n        },\n\n        /**\n         * Gets value of variable\n         *\n         * @param varName The name of the variable for which to get the value\n         * @return {*}\n         */\n        getVar : function(varName) {\n\n            /* Prepend dollar sign if not already there */\n            varName                             = (varName.indexOf('$') === 0) ? varName.substr(1) : varName;\n\n            return (typeof this.variables[varName] !== 'undefined') ? this.variables[varName] : null;\n        },\n\n        /**\n         * Gets value of  shortcut\n         *\n         * @param shortcut The name of the shortcut for which to get the value\n         * @return {*}\n         */\n        getShortcut : function(shortcut) {\n\n            /* Prepend @ symbol if not already there */\n            shortcut                            = (shortcut.indexOf('@') === 0) ? shortcut.substr(1) : shortcut;\n\n            return (typeof this.shortcuts[shortcut] !== 'undefined') ? this.shortcuts[shortcut] : null;\n        },\n\n        /**\n         * Replaces variables in workflow with values.\n         *\n         * Variables are defined in the initObj passed to the Turbine constructor. They are always\n         * prepended with a $ when referenced in the workflow.\n         *\n         * They work just like variables in any other programming language. Define them and\n         * then the value of the variable is used in its place.\n         *\n         * NOTE: Variables can only be used for scalar values. To replace non-scalar values,\n         * use mixins instead.\n         *\n         *\n         * \"variables\" : {\n         *     \"startOverTimeout\"       : \"30000\"\n         * }\n         *\n         * \"workflow\" : {\n         *     \"isStartOverAllowed\" : {\n         *         \"yes\" : {\n         *             \"waitFor\"            : \"App|process|restarted\",\n         *             \"timeout\" : {\n         *                 \"after\"          : \"$startOverTimeout\", // <-- This is the variable\n         *                 \"then\"           : \"stop.\"\n         *             },\n         *             \"then\"               : \"@start\"\n         *         },\n         *         \"no\" : {\n         *             \"then\"               : \"stop.\"\n         *         }\n         *     }\n         * }\n         *\n         * @param target The response in which the variables are being replaced\n         */\n        replaceVariables : function(target) {\n\n            var thisTarget, thisVar, replaceWith;\n\n            for (var variable in this.variables){\n\n                if (this.variables.hasOwnProperty(variable)){\n\n                    for (var item in target) {\n\n                        if (target.hasOwnProperty(item)) {\n\n                            thisTarget          = target[item];\n                            thisVar             = '$'+variable;\n                            replaceWith         = this.variables[variable];\n\n                            /* Replace variables with values defined in source */\n                            if (typeof thisTarget === 'string' && thisTarget.indexOf(thisVar) > -1) {\n\n                                if (!MINIFIED){\n                                    this.log('replace', 'Replacing ' + thisVar + ' variable with \"' + replaceWith + '\"', null , 'TRACE');\n                                }\n\n                                target[item]    = thisTarget.replace(new RegExp('\\\\'+thisVar,'g'),replaceWith);\n\n                            } else if (this.utils.isObjLiteral(thisTarget)) {\n\n                                this.replaceVariables(thisTarget);\n                            }\n                        }\n                    }\n                }\n            }\n        },\n\n        /**\n         * Replaces shortcuts in workflow with shortcut values. Shortcuts are defined in the\n         * initObj passed to the Turbine constructor, and are always prepended with an @ symbol\n         * when referenced in the workflow.\n         *\n         * Shortcuts are a way to reference a particular query in the workflow with an alias,\n         * rather than explicitly by name. For example, you may define a @start shortcut,\n         * and then reference that with \"then\":\n         *\n         *\n         * \"shortcuts\" : {\n         *     \"start\"      : \"isWorkflowActive\"\n         * }\n         *\n         * \"workflow\" : {\n         *\n         *     \"isStartOverAllowed\" : {\n         *         \"yes\" : {\n         *             \"then\"   : \"@start\" // <-- This is the shortcut\n         *         },\n         *         \"no\" : {\n         *             \"then\"   : \"stop.\"\n         *         }\n         *     }\n         * }\n         *\n         * If you decide to change the starting query of the workflow, you don't have to find and\n         * replace isWorkflowActive everywhere it occurs. Instead, you can just change the value of @start.\n         *\n         * @param response The response in which the shortcuts are being replaced\n         */\n        replaceShortcuts : function(response) {\n            this.replace(response,this.shortcuts,'@',true,'shortcut');\n        },\n\n        /**\n         * Replaces mixins in workflow with values.\n         *\n         * Mixins are a way to define an entire object as a reference, to avoid repeating the same\n         * object over and over.\n         *\n         * Mixins are defined in their own object in the workflow. The mixin name is always\n         * prepended with a plus sign when referenced in the workflow.\n         *\n         * For example:\n         *\n         * \"mixins\" : {\n         *     \"wrongPassword\" : {\n         *         \"publish\"               : \"UI.fail.show.PASSWORD_INCORRECT\",\n         *         \"then\"                  : \"stop.\"\n         *     },\n         *\n         *     \"DISCOUNT_APPLIED\" : {\n         *         \"message\"               : \"Cart|discount|applied\",\n         *          \"using\" : {\n         *              \"content\"           : \"discountApplied\",\n         *              \"discount\"          : \"$discountAmount\"\n         *          }\n         *      }\n         * }\n         *\n         * Then they are used like this:\n         *\n         * \"queries\" : {\n         *     \"isPasswordCorrect\" : {\n         *         \"yes\" : {\n         *             \"then\"               : \"isCreditCardOnFile\"\n         *         },\n         *         \"no\"                     : \"+wrongPassword\"      // <-- This is a mixin\n         *     },\n         *     \"isDiscountValid\" : {\n         *         publish                  : \"+DISCOUNT_APPLIED\",  // <-- This is a mixin\n         *         then                     : \"isCheckoutStarted\"\n         *     }\n         * }\n         *\n         * Mixins are replaced recursively, so mixins can be nested within other mixins\n         *\n         * @param target The target object in which to replace mixins\n         */\n        replaceMixins : function(target) {\n            this.replace(target,this.mixins,'+',true,'mixin');\n        },\n\n        /**\n         * Multipurpose function for replacing a key that is prepended with a string with a value, in an\n         * object (recursively if needed)\n         *\n         * @param target The target object in which the replacements should be made\n         * @param source The source object containing the values that will be inserted\n         * @param prepend The string prepended to they key (i.e. $foo, @bar, +baz)\n         * @param recursive If true, replacements will be done recursively in all nested objects\n         * @param type The type of replacement (mixin, shortcut)\n         */\n        replace : function(target,source,prepend,recursive,type) {\n\n            for (var item in target) {\n\n                if (target.hasOwnProperty(item)) {\n\n                    var thisItem                = target[item];\n\n                    /* Replace target with values defined in source */\n                    if (typeof thisItem === 'string' && thisItem.indexOf(prepend) === 0) {\n\n                        thisItem                = thisItem.substr(1);\n\n                        if (source[thisItem]) {\n\n                            if (!MINIFIED){\n                                this.log('replace', 'Replacing ' + prepend + thisItem + ' ' + type + ' with', source[thisItem], 'TRACE');\n                            }\n\n                            target[item]        = source[thisItem];\n                        }\n\n                    } else if (recursive && typeof thisItem === 'object') {\n\n                        this.replace(thisItem,source,prepend,recursive,type);\n                    }\n                }\n            }\n        },\n\n        utils : {\n\n            /**\n             * Checks whether obj is an array\n             *\n             * @param obj The object to check\n             */\n            isArray : function(obj) {\n                return Object.prototype.toString.call(obj) === '[object Array]';\n            },\n\n            /**\n             * Checks whether an item is already in the source array\n             *\n             * @param item The item to check\n             * @param source The source array in which to look\n             * @return {Boolean}\n             */\n            inArray : function(item,source) {\n\n                for (var i=0;i<source.length;i++) {\n\n                    if (item === source[i]) {\n                        return true;\n                    }\n                }\n\n                return false;\n            },\n\n            /**\n             * Checks whether an object is an object literal (non-null, non-array)\n             *\n             * @param obj The object to check\n             * @return {Boolean}\n             */\n            isObjLiteral : function(obj) {\n                return typeof obj === 'object' && obj !== null && !this.isArray(obj);\n            },\n\n            /**\n             * Recursively merges source object into target object\n             *\n             * @param target Target object\n             * @param source Source object\n             * @return {Object} Merged object\n             */\n            mergeObjects : function(target,source) {\n\n                for (var i in source) {\n\n                    if (source.hasOwnProperty(i)) {\n\n                        if ((typeof target[i] === 'object' && target[i] !== null) && (typeof source[i] === 'object' && source[i] !== null)) {\n\n                            target[i]           = this.mergeObjects(target[i],source[i]);\n\n                        } else {\n\n                            target[i]           = source[i];\n                        }\n                    }\n                }\n\n                return target;\n            },\n\n            // Recursively traverses an object, executing a callback on every node that's not another object\n            traverseObj : function (obj, depth, callback) {\n\n                // start at level 0\n                depth           = depth || 0;\n                callback        = callback || null;\n\n                for (var item in obj) {\n\n                    // if we find a child object\n                    if (obj.hasOwnProperty(item) && typeof obj[item] === 'object') {\n\n                        // recursively call myself again to loop through the child object\n                        // \"this\" refers to \"this.utils\"\n                        this.traverseObj(obj[item], ++depth, callback);\n\n                    } else if (callback) {\n\n                        callback(obj, item);\n                    }\n                }\n            }\n        }\n    };\n\n    /* If RequireJS define() is present, use it to export Turbine */\n    if (typeof define === \"function\") {\n\n        define(function() {\n            return Turbine;\n        });\n    }\n    /* Otherwise, add Turbine to global namespace */\n    else {\n\n        root.Turbine = Turbine;\n    }\n\n}(this)); // this will be window in a browser, global in NodeJS"}